-- print("including objectprot")

-- global management stuff:

objectprot = {moduleName} -- the granddaddy controller prototype that will hold the ancestral basic functions

objectprot.__index = objectprot -- if you're a kid and can't find something ask your parents

-- objectprot.guid = "none", -- no guid yet, this is just a prototype. but every instance should have a guid

objectprot.__call = function(sourceTable) -- attempting to call a controller instance as a function will return reference to its attached object.
  local guid = sourceTable.guid
  if not guid then
    print("tried to dereference prototype, but it had no guid attached!")
    return
  end
  local obj = getObjectFromGUID(guid)
  if obj == nil then
    print("self() object with guid " .. guid .. " does not exist!")
    -- print("dumping self instance " .. logString(sourceTable))
    return
  end
  return obj
end

-- straight from the textbook, make a new child of a self and set the parent (self) as the child's metatable for inheritance. unfortunately __index needs to be set manually for each new prototype, it's called with rawget() and thus not heritable.

local protList = {}
function objectprot:newProt(name, baseTable)
  local out = baseTable or {}

  if protList[name] then
    log("Tried to add duplicate prototype " .. name ..  "!") -- idk if i should add a check for duplicate values/baseTables
  else
    protList[name] = out
  end

  out.__index = out
  out.__call = objectprot.__call -- __call() should always be the same so we set it directly to objectprot's to avoid an extra metatable lookup.
  return setmetatable(out, self) -- makes an empty table and sets its metatable to self. the setmetatable function returns its first arg
end

function initController(obj)
  local controllerClass = protList[obj.getGMNotes():sub(a:find("^.-\n"))] -- first line of GMNotes is the controller class.
  if controllerClass then
    controllerClass:newInstance(obj)
  end
end
function initAllControllers() -- called from Global during global's onLoad()
  for i,obj in getAllObjects() do
    initController(obj)
  end
end
function onObjectSpawn(obj)
  initController(obj)
end


-- this initializes all internal, instance-specific variables. this is run during self:newInstance(). should be overriden/extended in children, but always return self.
function objectprot:init()
  return self
end

function objectprot:newInstance(initarg, ...) -- initializes a new instance of a class based on target obj and any other arguments. do not call from instance, only from prototype. for reference a prototype has self.__index == self
  local out = setmetatable({}, self) -- remember setmetatable returns its first argument

  local guid = type(initarg) == "userdata" and initarg.guid or initarg -- initarg is either userdata or a guid string. if it's userdata, get guid, else it should be a string and we can assign directly
  assert(type(guid) == "string", "init argument is not a not valid (userdata or guid), it's a " .. type(initarg))
  out.guid = guid -- every instance needs a guid
  return out:init(...) -- any additional args are passed on to init
end

-- functions to read and write script_state. can be overriden/extended ofc
-- followup: use binser or some other format instead of JSON if this turns out to be too slow
-- i also considered using getTable instead of decoding script_state but was told they're about equally slow since getTable does a deepcopy.
function objectprot:readSave()
  local raw = JSON.decode(self().script_state) -- the first six characters of script_state on each object are reserved for its module's guid
  return type(raw) == "table" and raw or {} -- falls back to returning an empty table if script_state is not a table (e.g a nil or an empty string)
end
function objectprot:writeSave(arg)
  self().script_state = JSON.encode(arg)
end

-- ripped from https://github.com/tjakubo2/TTS_xwing/blob/2db37acb2960474f095fb8d47fa8654044af972e/Global.-1.ttslua#L3398
charWidthTable = {
        ['`'] = 2381, ['~'] = 2381, ['1'] = 1724, ['!'] = 1493, ['2'] = 2381,
        ['@'] = 4348, ['3'] = 2381, ['#'] = 3030, ['4'] = 2564, ['$'] = 2381,
        ['5'] = 2381, ['%'] = 3846, ['6'] = 2564, ['^'] = 2564, ['7'] = 2174,
        ['&'] = 2777, ['8'] = 2564, ['*'] = 2174, ['9'] = 2564, ['('] = 1724,
        ['0'] = 2564, [')'] = 1724, ['-'] = 1724, ['_'] = 2381, ['='] = 2381,
        ['+'] = 2381, ['q'] = 2564, ['Q'] = 3226, ['w'] = 3704, ['W'] = 4167,
        ['e'] = 2174, ['E'] = 2381, ['r'] = 1724, ['R'] = 2777, ['t'] = 1724,
        ['T'] = 2381, ['y'] = 2564, ['Y'] = 2564, ['u'] = 2564, ['U'] = 3030,
        ['i'] = 1282, ['I'] = 1282, ['o'] = 2381, ['O'] = 3226, ['p'] = 2564,
        ['P'] = 2564, ['['] = 1724, ['{'] = 1724, [']'] = 1724, ['}'] = 1724,
        ['|'] = 1493, ['\\'] = 1923, ['a'] = 2564, ['A'] = 2777, ['s'] = 1923,
        ['S'] = 2381, ['d'] = 2564, ['D'] = 3030, ['f'] = 1724, ['F'] = 2381,
        ['g'] = 2564, ['G'] = 2777, ['h'] = 2564, ['H'] = 3030, ['j'] = 1075,
        ['J'] = 1282, ['k'] = 2381, ['K'] = 2777, ['l'] = 1282, ['L'] = 2174,
        [';'] = 1282, [':'] = 1282, ['\''] = 855, ['"'] = 1724, ['z'] = 1923,
        ['Z'] = 2564, ['x'] = 2381, ['X'] = 2777, ['c'] = 1923, ['C'] = 2564,
        ['v'] = 2564, ['V'] = 2777, ['b'] = 2564, ['B'] = 2564, ['n'] = 2564,
        ['N'] = 3226, ['m'] = 3846, ['M'] = 3846, [','] = 1282, ['<'] = 2174,
        ['.'] = 1282, ['>'] = 2174, ['/'] = 1923, ['?'] = 2174, [' '] = 1282,
        ['avg'] = 2500
    }
-- Get real string lenght per char table
function calcButtonWidth(str)
    local len = 0
    for i = 1, #str do
        local c = str:sub(i,i)
        if StringLen.charWidthTable[c] ~= nil then
            len = len + StringLen.charWidthTable[c]
        else
            len = len + StringLen.charWidthTable.avg
        end
    end
    return len
end

-- a couple misecllaneous ui functions for convenience
function objectprot:makeContextMenu(methodName, closure, keep_open) -- this lets us easily put table:func() type functions into context menus.
  if methodName == "" then
    self().addContextMenuItem("-------", function() return end, true)
  else
    local closure = closure or function(player, obj) self[methodName](self, player, obj) end -- remember that a custom closure will still be called as closure(player, obj)
    self().addContextMenuItem(methodName, closure, keep_open or false) -- closures are hard
  end
end
function objectprot:resetUI()
  local realObj = self()
  realObj.clearInputs()
  realObj.clearButtons()
  realObj.clearContextMenu()
  realObj.highlightOff()
end
function objectprot:playerPrint(str, player, color) -- to print to all with color, should be called as self:playerPrint(str, nil, color)
  if player then
    printToColor(str, player, color)
  else
    printToAll(str, color)
  end
end

-- interface to call from external unity objects
-- don't go overboard when using Global.call with this, since it does a deepcopy of argTable every time. if possible, just rely on data inherent to the object (or its script_state, which can be read with self:readSave() anyway).
-- syntax for the call: Global.call("newFromGlobalCall", {prot = objectprot, obj = self})
-- syntax for the call with params: Global.call("newFromGlobalCall", {prot = "objectprot", obj = self, params = table.pack(arg1, arg2, ...)})
-- function newFromGlobalCall(argTable)
--   -- local prot = dynamic.eval(argTable.prot) -- this should be the table we want. remember that eval gives direct access only and does NOT work with metatables.
--   local prot = _G[argTable.prot]
--   assert(type(prot) == "table", "eval did not result in table!")
--   -- print("prot", logString(prot))
--   -- print("protmt", logString(getmetatable(prot)))
--   prot:newInstance(argTable.obj, unpack(argTable.params, 1, argTable.params.n))
-- end
